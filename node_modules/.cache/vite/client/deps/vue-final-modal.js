import "./chunk-JLSDPW4D.js";
import {
  Transition,
  vShow,
  withKeys,
  withModifiers
} from "./chunk-MNWBZQKJ.js";
import {
  Fragment,
  Teleport,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createVNode,
  defineComponent,
  getCurrentInstance,
  guardReactiveProps,
  inject,
  mergeProps,
  nextTick,
  onBeforeUnmount,
  onMounted,
  openBlock,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  toHandlers,
  useAttrs,
  watch,
  withCtx,
  withDirectives
} from "./chunk-3Q27KRJ5.js";
import {
  markRaw,
  reactive,
  ref,
  shallowReactive,
  toRef,
  unref
} from "./chunk-BOVKDABU.js";
import {
  normalizeClass,
  normalizeProps,
  normalizeStyle
} from "./chunk-V6R5RJCE.js";
import "./chunk-TFWDKVI3.js";

// node_modules/@vueuse/shared/index.mjs
import { shallowRef, watchEffect, readonly, unref as unref2, ref as ref2, isVue3, version, watch as watch2, customRef, getCurrentScope, onScopeDispose, effectScope, provide, inject as inject2, isRef, computed as computed2, reactive as reactive2, toRefs as toRefs$1, toRef as toRef2, isVue2, set as set$1, getCurrentInstance as getCurrentInstance2, onBeforeMount, nextTick as nextTick2, onBeforeUnmount as onBeforeUnmount2, onMounted as onMounted2, onUnmounted, isReactive } from "vue-demi";
var _a;
var isClient = typeof window !== "undefined";
var isString = (val) => typeof val === "string";
var noop = () => {
};
var isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function resolveUnref(r) {
  return typeof r === "function" ? r() : unref2(r);
}
function identity(arg) {
  return arg;
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function tryOnUnmounted(fn) {
  if (getCurrentInstance2())
    onUnmounted(fn);
}

// node_modules/@vueuse/core/index.mjs
import { isRef as isRef2, ref as ref3, shallowRef as shallowRef2, watchEffect as watchEffect2, computed as computed3, inject as inject3, unref as unref3, watch as watch3, getCurrentInstance as getCurrentInstance3, customRef as customRef2, onUpdated, reactive as reactive3, nextTick as nextTick3, onMounted as onMounted3, markRaw as markRaw2, readonly as readonly2, getCurrentScope as getCurrentScope2, isVue2 as isVue22, set, del, isReadonly, onBeforeUpdate } from "vue-demi";
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (isString(args[0]) || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch3(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
    cleanup();
    if (!el)
      return;
    cleanups.push(...events.flatMap((event) => {
      return listeners.map((listener) => register(el, event, listener, options2));
    }));
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
var handlers = _global[globalKey];
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = __spreadValues({
  linear: identity
}, _TransitionPresets);

// node_modules/@vueuse/integrations/useFocusTrap.mjs
import { ref as ref4, watch as watch4 } from "vue-demi";

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

// node_modules/focus-trap/dist/focus-trap.esm.js
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e) {
  return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
};
var isTabEvent = function isTabEvent2(e) {
  return e.key === "Tab" || e.keyCode === 9;
};
var isKeyForward = function isKeyForward2(e) {
  return isTabEvent(e) && !e.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i) {
    if (fn(value)) {
      idx = i;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element) {
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      return {
        container,
        tabbableNodes,
        focusableNodes,
        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = focusableNodes.findIndex(function(n) {
            return n === node;
          });
          if (nodeIdx < 0) {
            return void 0;
          }
          if (forward) {
            return focusableNodes.slice(nodeIdx + 1).find(function(n) {
              return isTabbable(n, config.tabbableOptions);
            });
          }
          return focusableNodes.slice(0, nodeIdx).reverse().find(function(n) {
            return isTabbable(n, config.tabbableOptions);
          });
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var checkPointerDown = function checkPointerDown2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(e) {
    var target = getActualTarget(e);
    var targetContained = findContainerIndex(target) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      e.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };
  var checkKeyNav = function checkKeyNav2(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var target = getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    if (destinationNode) {
      if (isTabEvent(event)) {
        event.preventDefault();
      }
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
      return;
    }
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkClick = function checkClick2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 ? void 0 : onActivate();
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        onPostActivate === null || onPostActivate === void 0 ? void 0 : onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 ? void 0 : onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 ? void 0 : onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (state.paused || !state.active) {
        return this;
      }
      var onPause = getOption(pauseOptions, "onPause");
      var onPostPause = getOption(pauseOptions, "onPostPause");
      state.paused = true;
      onPause === null || onPause === void 0 ? void 0 : onPause();
      removeListeners();
      onPostPause === null || onPostPause === void 0 ? void 0 : onPostPause();
      return this;
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.paused || !state.active) {
        return this;
      }
      var onUnpause = getOption(unpauseOptions, "onUnpause");
      var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
      state.paused = false;
      onUnpause === null || onUnpause === void 0 ? void 0 : onUnpause();
      updateTabbableNodes();
      addListeners();
      onPostUnpause === null || onPostUnpause === void 0 ? void 0 : onPostUnpause();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};

// node_modules/@vueuse/integrations/useFocusTrap.mjs
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useFocusTrap(target, options = {}) {
  let trap;
  const _a2 = options, { immediate } = _a2, focusTrapOptions = __objRest(_a2, ["immediate"]);
  const hasFocus = ref4(false);
  const isPaused = ref4(false);
  const activate = (opts) => trap && trap.activate(opts);
  const deactivate = (opts) => trap && trap.deactivate(opts);
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.value = true;
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.value = false;
    }
  };
  watch4(() => unrefElement(target), (el) => {
    if (!el)
      return;
    trap = createFocusTrap(el, __spreadProps(__spreadValues2({}, focusTrapOptions), {
      onActivate() {
        hasFocus.value = true;
        if (options.onActivate)
          options.onActivate();
      },
      onDeactivate() {
        hasFocus.value = false;
        if (options.onDeactivate)
          options.onDeactivate();
      }
    }));
    if (immediate)
      activate();
  }, { flush: "post" });
  tryOnScopeDispose(() => deactivate());
  return {
    hasFocus,
    isPaused,
    activate,
    deactivate,
    pause,
    unpause
  };
}

// node_modules/vue-final-modal/dist/index.es.js
var fe = {
  /**
   * @description An uniq name for the open/close a modal via vfm.open/vfm.close APIs.
   * @default `undefined`
   * @example Symbol: `Symbol('MyModal')`
   * @example String: `'AUniqString'`
   * @example Number: `300`
   */
  modalId: {
    type: [String, Number, Symbol],
    default: void 0
  },
  /**
   * @description Display the modal or not.
   * @default `undefined`
   * @example
   * ```js
   * const showModal = ref(false)
   * v-model="showModal"
   * ```
   */
  modelValue: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Render the modal via `if` or `show`.
   * @default `'if'`
   * @example
   * ```js
   * displayDirective: 'if'
   * ```
   * @example
   * ```js
   * displayDirective: 'show'
   * ```
   */
  displayDirective: {
    type: String,
    default: "if",
    validator: (e) => ["if", "show"].includes(e)
  },
  /**
   * @description Hide the overlay or not.
   * @default `undefined`
   * @example
   * ```js
   * hideOverlay="true"
   * ```
   */
  hideOverlay: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Customize the overlay transition.
   * @default `undefined`
   */
  overlayTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Customize the content transition.
   * @default `undefined`
   */
  contentTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Bind class to vfm__overlay.
   * @default `undefined`
   */
  overlayClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind class to vfm__content.
   * @default `undefined`
   */
  contentClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind style to vfm__overlay.
   * @default `undefined`
   */
  overlayStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Bind style to vfm__content.
   * @default `undefined`
   */
  contentStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Is it allow to close the modal by clicking the overlay.
   * @default `true`
   */
  clickToClose: {
    type: Boolean,
    default: true
  },
  /**
   * @description Is it allow to close the modal by keypress `esc`.
   * @default `true`
   */
  escToClose: {
    type: Boolean,
    default: true
  },
  /**
   * @description Is it allow to click outside of the vfm__content when the modal is opened
   * @default `'non-interactive'`
   */
  background: {
    type: String,
    default: "non-interactive",
    validator: (e) => ["interactive", "non-interactive"].includes(e)
  },
  /**
   * @description
   * * Use `{ disabled: true }` to disable the focusTrap.
   * * Checkout the createOptions type here https://github.com/focus-trap/focus-trap for more.
   * @default `{ allowOutsideClick: true }`
   */
  focusTrap: {
    type: [Boolean, Object],
    default: () => ({
      allowOutsideClick: true
    })
  },
  /**
   * @description Lock body scroll or not when the modal is opened.
   * @default `true`
   */
  lockScroll: {
    type: Boolean,
    default: true
  },
  /**
   * @description Define how to increase the zIndex when there are nested modals
   * @default `({ index }) => 1000 + 2 * index`
   */
  zIndexFn: {
    type: Function,
    default: ({ index: e }) => 1e3 + 2 * e
  },
  /**
   * @description The direction of swiping to close the modal
   * @default `none`
   * @example
   * Set swipeToClose="none" to disable swiping to close
   * ```js
   * swipeToClose="none"
   * ```
   */
  swipeToClose: {
    type: String,
    default: "none",
    validator: (e) => ["none", "up", "right", "down", "left"].includes(e)
  },
  /**
   * @description Threshold for swipe to close
   * @default `0`
   */
  threshold: {
    type: Number,
    default: 0
  },
  /**
   * @description If set `:showSwipeBanner="true"`, only allow clicking `swipe-banner` slot to swipe to close
   * @default `undefined`
   * @example
   * ```js
   * swipeToClose="right"
   * :showSwipeBanner="true"
   * ```
   * ```html
   * <VueFinalModal
   *   ...
   *   swipeToClose="right"
   *   :showSwipeBanner="true"
   * >
   *   <template #swipe-banner>
   *     <div style="position: absolute; height: 100%; top: 0; left: 0; width: 10px;" />
   *   </template>
   *   ...modal content
   * </VueFinalModal>
   * ```
   */
  showSwipeBanner: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description When set `:preventNavigationGestures="true"`, there will be two invisible bars for prevent navigation gestures including swiping back/forward on mobile webkit. For example: Safari mobile.
   * @default `undefined`
   * @example
   * Set preventNavigationGestures="true" to prevent Safari navigation gestures including swiping back/forward.
   * ```js
   * :preventNavigationGestures="true"
   * ```
   */
  preventNavigationGestures: {
    type: Boolean,
    default: void 0
  }
};
function Ee(e = false) {
  const o = ref(e), t = ref(o.value ? 0 : void 0);
  return [o, t, {
    beforeEnter() {
      t.value = 1;
    },
    afterEnter() {
      t.value = 0;
    },
    beforeLeave() {
      t.value = 3;
    },
    afterLeave() {
      t.value = 2;
    }
  }];
}
function lo(e, o) {
  const { modelValueLocal: t, onEntering: r, onEnter: d, onLeaving: u, onLeave: s } = o, n = ref(t.value), [l, i, y] = Ee(n.value), [c, M, b] = Ee(n.value), g = computed(() => typeof e.contentTransition == "string" ? { name: e.contentTransition } : { ...e.contentTransition }), B = computed(() => typeof e.overlayTransition == "string" ? { name: e.overlayTransition } : { ...e.overlayTransition }), k = computed(
    () => (e.hideOverlay || M.value === 2) && i.value === 2
    /* Leave */
  );
  watch(
    k,
    (L) => {
      L && (n.value = false);
    }
  ), watch(i, (L) => {
    switch (L) {
      case 1:
        return r == null ? void 0 : r();
      case 0:
        return d == null ? void 0 : d();
      case 3:
        return u == null ? void 0 : u();
      case 2:
        return s == null ? void 0 : s();
    }
  });
  async function T() {
    n.value = true, await nextTick(), l.value = true, c.value = true;
  }
  function S() {
    l.value = false, c.value = false;
  }
  return {
    visible: n,
    contentVisible: l,
    contentListeners: y,
    contentTransition: g,
    overlayVisible: c,
    overlayListeners: b,
    overlayTransition: B,
    enterTransition: T,
    leaveTransition: S
  };
}
function so(e, o, t) {
  const { vfmRootEl: r, vfmContentEl: d, visible: u, modelValueLocal: s } = t, n = ref();
  function l() {
    u.value && e.escToClose && (s.value = false);
  }
  function i(c) {
    n.value = c == null ? void 0 : c.target;
  }
  function y() {
    var c;
    n.value === r.value && (e.clickToClose ? s.value = false : ((c = d.value) == null || c.focus(), o("clickOutside")));
  }
  return {
    onEsc: l,
    onMouseupRoot: y,
    onMousedown: i
  };
}
function ro(e, o) {
  const t = ref(!!e.modelValue);
  return watch(() => e.modelValue, (r) => {
    t.value = !!r;
  }), watch(t, (r) => {
    r !== e.modelValue && o("update:modelValue", r);
  }), {
    modelValueLocal: t
  };
}
function ao(e, o) {
  if (e.focusTrap === false)
    return {
      focus() {
      },
      blur() {
      }
    };
  const { focusEl: t } = o, { hasFocus: r, activate: d, deactivate: u } = useFocusTrap(t, e.focusTrap);
  function s() {
    requestAnimationFrame(() => {
      d();
    });
  }
  function n() {
    r.value && u();
  }
  return { focus: s, blur: n };
}
var ve = false;
if (typeof window < "u") {
  const e = {
    get passive() {
      ve = true;
    }
  };
  window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e);
}
var Fe = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
var H = [];
var te = false;
var _ = 0;
var xe = -1;
var X;
var U;
var io = (e) => {
  if (!e || e.nodeType !== Node.ELEMENT_NODE)
    return false;
  const o = window.getComputedStyle(e);
  return ["auto", "scroll"].includes(o.overflowY) && e.scrollHeight > e.clientHeight;
};
var uo = (e, o) => !(e.scrollTop === 0 && o < 0 || e.scrollTop + e.clientHeight + o >= e.scrollHeight && o > 0);
var co = (e) => {
  const o = [];
  for (; e; ) {
    if (o.push(e), e.classList.contains("vfm"))
      return o;
    e = e.parentElement;
  }
  return o;
};
var fo = (e, o) => {
  let t = false;
  return co(e).forEach((d) => {
    io(d) && uo(d, o) && (t = true);
  }), t;
};
var Re = (e) => H.some(() => fo(e, -_));
var le = (e) => {
  const o = e || window.event;
  return Re(o.target) || o.touches.length > 1 ? true : (o.preventDefault && o.preventDefault(), false);
};
var vo = (e) => {
  if (U === void 0) {
    const o = !!e && e.reserveScrollBarGap === true, t = window.innerWidth - document.documentElement.clientWidth;
    if (o && t > 0) {
      const r = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
      U = document.body.style.paddingRight, document.body.style.paddingRight = `${r + t}px`;
    }
  }
  X === void 0 && (X = document.body.style.overflow, document.body.style.overflow = "hidden");
};
var po = () => {
  U !== void 0 && (document.body.style.paddingRight = U, U = void 0), X !== void 0 && (document.body.style.overflow = X, X = void 0);
};
var mo = (e) => e ? e.scrollHeight - e.scrollTop <= e.clientHeight : false;
var yo = (e, o) => (_ = e.targetTouches[0].clientY - xe, Re(e.target) ? false : o && o.scrollTop === 0 && _ > 0 || mo(o) && _ < 0 ? le(e) : (e.stopPropagation(), true));
var ho = (e, o) => {
  if (!e) {
    console.error(
      "disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."
    );
    return;
  }
  if (H.some((r) => r.targetElement === e))
    return;
  const t = {
    targetElement: e,
    options: o || {}
  };
  H = [...H, t], Fe ? (e.ontouchstart = (r) => {
    r.targetTouches.length === 1 && (xe = r.targetTouches[0].clientY);
  }, e.ontouchmove = (r) => {
    r.targetTouches.length === 1 && yo(r, e);
  }, te || (document.addEventListener("touchmove", le, ve ? { passive: false } : void 0), te = true)) : vo(o);
};
var wo = (e) => {
  if (!e) {
    console.error(
      "enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices."
    );
    return;
  }
  H = H.filter((o) => o.targetElement !== e), Fe ? (e.ontouchstart = null, e.ontouchmove = null, te && H.length === 0 && (document.removeEventListener("touchmove", le, ve ? { passive: false } : void 0), te = false)) : H.length || po();
};
function bo(e, o) {
  const { lockScrollEl: t, modelValueLocal: r } = o;
  let d;
  watch(t, (n) => {
    n && (d = n);
  }, { immediate: true }), watch(() => e.lockScroll, (n) => {
    n ? s() : u();
  }), onBeforeUnmount(() => {
    u();
  });
  function u() {
    d && wo(d);
  }
  function s() {
    r.value && e.lockScroll && d && ho(d, {
      reserveScrollBarGap: true,
      allowTouchMove: (n) => {
        for (; n && n !== document.body; ) {
          if (n.getAttribute("vfm-scroll-lock-ignore") !== null)
            return true;
          n = n.parentElement;
        }
        return false;
      }
    });
  }
  return {
    enableBodyScroll: u,
    disableBodyScroll: s
  };
}
function To(e) {
  function o(t) {
    switch (t) {
      case "beforeOpen":
        e(t);
        break;
      case "beforeClose":
        e(t);
        break;
      case "opened":
        e(t);
        break;
      case "closed":
        e(t);
        break;
    }
  }
  return {
    emitEvent: o
  };
}
function Mo(e) {
  const o = ref();
  function t(d) {
    var u;
    o.value = (u = e.zIndexFn) == null ? void 0 : u.call(e, { index: d <= -1 ? 0 : d });
  }
  function r() {
    o.value = void 0;
  }
  return {
    zIndex: o,
    refreshZIndex: t,
    resetZIndex: r
  };
}
var So = (e) => (...o) => {
  e && (e == null || e(...o), e = null);
};
var A = () => {
};
function J(e, o, t) {
  return e > t ? t : e < o ? o : e;
}
var Be = (e) => {
  if (e instanceof MouseEvent) {
    const { clientX: o, clientY: t } = e;
    return { x: o, y: t };
  } else {
    const { clientX: o, clientY: t } = e.targetTouches[0];
    return { x: o, y: t };
  }
};
function Oo(e) {
  if (!e)
    return false;
  let o = false;
  const t = {
    get passive() {
      return o = true, false;
    }
  };
  return e.addEventListener("x", A, t), e.removeEventListener("x", A), o;
}
function Co(e, {
  threshold: o = 0,
  onSwipeStart: t,
  onSwipe: r,
  onSwipeEnd: d,
  passive: u = true
}) {
  const s = reactive({ x: 0, y: 0 }), n = reactive({ x: 0, y: 0 }), l = computed(() => s.x - n.x), i = computed(() => s.y - n.y), { max: y, abs: c } = Math, M = computed(
    () => y(c(l.value), c(i.value)) >= o
  ), b = ref(false), g = computed(() => M.value ? c(l.value) > c(i.value) ? l.value > 0 ? "left" : "right" : i.value > 0 ? "up" : "down" : "none"), B = (f, h) => {
    s.x = f, s.y = h;
  }, k = (f, h) => {
    n.x = f, n.y = h;
  };
  let T, S;
  function L(f) {
    T.capture && !T.passive && f.preventDefault();
    const { x: h, y: F } = Be(f);
    B(h, F), k(h, F), t == null || t(f), S = [
      useEventListener(e, "mousemove", N, T),
      useEventListener(e, "touchmove", N, T),
      useEventListener(e, "mouseup", a, T),
      useEventListener(e, "touchend", a, T),
      useEventListener(e, "touchcancel", a, T)
    ];
  }
  function N(f) {
    const { x: h, y: F } = Be(f);
    k(h, F), !b.value && M.value && (b.value = true), b.value && (r == null || r(f));
  }
  function a(f) {
    b.value && (d == null || d(f, g.value)), b.value = false, S.forEach((h) => h());
  }
  let v = [];
  return onMounted(() => {
    const f = Oo(window == null ? void 0 : window.document);
    u ? T = f ? { passive: true } : { capture: false } : T = f ? { passive: false, capture: true } : { capture: true }, v = [
      useEventListener(e, "mousedown", L, T),
      useEventListener(e, "touchstart", L, T)
    ];
  }), {
    isSwiping: b,
    direction: g,
    coordsStart: s,
    coordsEnd: n,
    lengthX: l,
    lengthY: i,
    stop: () => {
      v.forEach((f) => f()), S.forEach((f) => f());
    }
  };
}
function go(e, o) {
  const { vfmContentEl: t, modelValueLocal: r } = o, d = 0.1, u = 300, s = ref(), n = computed(() => {
    if (!(e.swipeToClose === void 0 || e.swipeToClose === "none"))
      return e.showSwipeBanner ? s.value : t.value;
  }), l = ref(0), i = ref(true);
  let y = A, c = true, M, b = false;
  const { lengthX: g, lengthY: B, direction: k, isSwiping: T } = Co(n, {
    threshold: e.threshold,
    onSwipeStart(a) {
      y = useEventListener(document, "selectionchange", () => {
        var v;
        i.value = (v = window.getSelection()) == null ? void 0 : v.isCollapsed;
      }), M = (/* @__PURE__ */ new Date()).getTime(), b = N(a == null ? void 0 : a.target);
    },
    onSwipe() {
      var a, v, V, f;
      if (b && i.value && k.value === e.swipeToClose) {
        if (k.value === "up") {
          const h = J(Math.abs(B.value || 0), 0, ((a = n.value) == null ? void 0 : a.offsetHeight) || 0) - (e.threshold || 0);
          l.value = h;
        } else if (k.value === "down") {
          const h = J(Math.abs(B.value || 0), 0, ((v = n.value) == null ? void 0 : v.offsetHeight) || 0) - (e.threshold || 0);
          l.value = -h;
        } else if (k.value === "right") {
          const h = J(Math.abs(g.value || 0), 0, ((V = n.value) == null ? void 0 : V.offsetWidth) || 0) - (e.threshold || 0);
          l.value = -h;
        } else if (k.value === "left") {
          const h = J(Math.abs(g.value || 0), 0, ((f = n.value) == null ? void 0 : f.offsetWidth) || 0) - (e.threshold || 0);
          l.value = h;
        }
      }
    },
    onSwipeEnd(a, v) {
      if (y(), !i.value) {
        i.value = true;
        return;
      }
      const V = (/* @__PURE__ */ new Date()).getTime(), f = v === e.swipeToClose, h = (() => {
        var Y, K;
        if (v === "up" || v === "down")
          return Math.abs((B == null ? void 0 : B.value) || 0) > d * (((Y = n.value) == null ? void 0 : Y.offsetHeight) || 0);
        if (v === "left" || v === "right")
          return Math.abs((g == null ? void 0 : g.value) || 0) > d * (((K = n.value) == null ? void 0 : K.offsetWidth) || 0);
      })(), F = V - M <= u;
      if (c && b && f && (h || F)) {
        r.value = false;
        return;
      }
      l.value = 0;
    }
  }), S = computed(() => {
    if (e.swipeToClose === "none")
      return;
    const a = (() => {
      switch (e.swipeToClose) {
        case "up":
        case "down":
          return "translateY";
        case "left":
        case "right":
          return "translateX";
      }
    })();
    return {
      class: { "vfm-bounce-back": !T.value },
      style: { transform: `${a}(${-l.value}px)` }
    };
  });
  watch(
    () => i.value,
    (a) => {
      a || (l.value = 0);
    }
  ), watch(
    () => r.value,
    (a) => {
      a && (l.value = 0);
    }
  ), watch(
    () => l.value,
    (a, v) => {
      switch (e.swipeToClose) {
        case "down":
        case "right":
          c = a < v;
          break;
        case "up":
        case "left":
          c = a > v;
          break;
      }
    }
  );
  function L(a) {
    e.preventNavigationGestures && a.preventDefault();
  }
  function N(a) {
    const v = a == null ? void 0 : a.tagName;
    if (!v || ["INPUT", "TEXTAREA"].includes(v))
      return false;
    const V = (() => {
      switch (e.swipeToClose) {
        case "up":
          return (a == null ? void 0 : a.scrollTop) + (a == null ? void 0 : a.clientHeight) === (a == null ? void 0 : a.scrollHeight);
        case "left":
          return (a == null ? void 0 : a.scrollLeft) + (a == null ? void 0 : a.clientWidth) === (a == null ? void 0 : a.scrollWidth);
        case "down":
          return (a == null ? void 0 : a.scrollTop) === 0;
        case "right":
          return (a == null ? void 0 : a.scrollLeft) === 0;
        default:
          return false;
      }
    })();
    return a === n.value ? V : V && N(a == null ? void 0 : a.parentElement);
  }
  return {
    vfmContentEl: t,
    swipeBannerEl: s,
    bindSwipe: S,
    onTouchStartSwipeBanner: L
  };
}
var pe = Symbol("vfm");
var me = Symbol("internalVfm");
var ko = defineComponent({
  __name: "CoreModal",
  props: fe,
  emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
  setup(e, { emit: o }) {
    const t = e, { modals: r, openedModals: d } = inject(pe, {
      modals: [],
      openedModals: []
    }), {
      openLastOverlay: u,
      moveToLastOpenedModals: s,
      deleteFromOpenedModals: n,
      moveToLastOpenedModalOverlays: l,
      deleteFromOpenedModalOverlays: i,
      deleteFromModals: y
    } = inject(me, {
      openLastOverlay: A,
      moveToLastOpenedModals: A,
      deleteFromOpenedModals: A,
      moveToLastOpenedModalOverlays: A,
      deleteFromOpenedModalOverlays: A,
      deleteFromModals: A
    }), c = ref(), M = ref(), { focus: b, blur: g } = ao(t, { focusEl: c }), { zIndex: B, refreshZIndex: k, resetZIndex: T } = Mo(t), { modelValueLocal: S } = ro(t, o), { enableBodyScroll: L, disableBodyScroll: N } = bo(t, {
      lockScrollEl: c,
      modelValueLocal: S
    }), { emitEvent: a } = To(o);
    let v = A;
    const {
      visible: V,
      contentVisible: f,
      contentListeners: h,
      contentTransition: F,
      overlayVisible: Y,
      overlayListeners: K,
      overlayTransition: He,
      enterTransition: Ne,
      leaveTransition: je
    } = lo(t, {
      modelValueLocal: S,
      onEntering() {
        nextTick(() => {
          N();
        });
      },
      onEnter() {
        b(), a("opened"), v("opened");
      },
      onLeave() {
        n(We()), T(), L(), a("closed"), v("closed");
      }
    }), { onEsc: Ye, onMouseupRoot: $e, onMousedown: ye } = so(t, o, { vfmRootEl: c, vfmContentEl: M, visible: V, modelValueLocal: S }), {
      swipeBannerEl: ze,
      bindSwipe: Ge,
      onTouchStartSwipeBanner: he
    } = go(t, { vfmContentEl: M, modelValueLocal: S }), we = toRef(t, "hideOverlay"), D = computed(() => ({
      modalId: t.modalId,
      hideOverlay: we,
      overlayVisible: Y,
      focus: b,
      toggle(p) {
        return new Promise((w) => {
          v = So((Ue) => w(Ue));
          const O = typeof p == "boolean" ? p : !S.value;
          S.value = O, o("update:modelValue", O);
        });
      }
    }));
    function We() {
      return D;
    }
    const re = computed(() => d.indexOf(D));
    watch(() => [t.zIndexFn, re.value], () => {
      V.value && k(re.value);
    }), onMounted(() => {
      r.push(D);
    }), S.value && be(), watch(S, (p) => {
      p ? be() : Xe();
    });
    async function be() {
      a("beforeOpen"), s(D), l(D), k(re.value), u(), Ne();
    }
    function Xe() {
      a("beforeClose"), i(D), u(), g(), je();
    }
    return onBeforeUnmount(() => {
      L(), y(D), n(D), i(D), g(), u();
    }), (p, w) => p.displayDirective !== "if" || unref(V) ? withDirectives((openBlock(), createElementBlock("div", {
      key: 0,
      ref_key: "vfmRootEl",
      ref: c,
      class: normalizeClass(["vfm vfm--fixed vfm--inset", { "vfm--prevent-none": p.background === "interactive" }]),
      style: normalizeStyle({ zIndex: unref(B) }),
      role: "dialog",
      "aria-modal": "true",
      onKeydown: w[7] || (w[7] = withKeys(() => unref(Ye)(), ["esc"])),
      onMouseup: w[8] || (w[8] = withModifiers(() => unref($e)(), ["self"])),
      onMousedown: w[9] || (w[9] = withModifiers((O) => unref(ye)(O), ["self"]))
    }, [
      unref(we) ? createCommentVNode("", true) : (openBlock(), createBlock(Transition, mergeProps({ key: 0 }, unref(He), {
        appear: p.displayDirective === "if"
      }, toHandlers(unref(K))), {
        default: withCtx(() => [
          unref(Y) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["vfm__overlay vfm--overlay vfm--absolute vfm--inset vfm--prevent-none", p.overlayClass]),
            style: normalizeStyle(p.overlayStyle),
            "aria-hidden": "true"
          }, null, 6)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 16, ["appear"])),
      createVNode(Transition, mergeProps(unref(F), {
        appear: p.displayDirective === "if"
      }, toHandlers(unref(h))), {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", mergeProps({
            ref_key: "vfmContentEl",
            ref: M,
            class: ["vfm__content vfm--outline-none", [p.contentClass, { "vfm--prevent-auto": p.background === "interactive" }]],
            style: p.contentStyle,
            tabindex: "0"
          }, unref(Ge), {
            onMousedown: w[6] || (w[6] = () => unref(ye)())
          }), [
            renderSlot(p.$slots, "default"),
            p.showSwipeBanner ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_key: "swipeBannerEl",
              ref: ze,
              class: "vfm-swipe-banner-container",
              onTouchstart: w[2] || (w[2] = (O) => unref(he)(O))
            }, [
              renderSlot(p.$slots, "swipe-banner", {}, () => [
                createBaseVNode("div", {
                  class: "vfm-swipe-banner-back",
                  onTouchstart: w[0] || (w[0] = (O) => p.swipeToClose === "left" && O.preventDefault())
                }, null, 32),
                createBaseVNode("div", {
                  class: "vfm-swipe-banner-forward",
                  onTouchstart: w[1] || (w[1] = (O) => p.swipeToClose === "right" && O.preventDefault())
                }, null, 32)
              ])
            ], 544)) : !p.showSwipeBanner && p.preventNavigationGestures ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "vfm-swipe-banner-container",
              onTouchstart: w[5] || (w[5] = (O) => unref(he)(O))
            }, [
              createBaseVNode("div", {
                class: "vfm-swipe-banner-back",
                onTouchstart: w[3] || (w[3] = (O) => p.swipeToClose === "left" && O.preventDefault())
              }, null, 32),
              createBaseVNode("div", {
                class: "vfm-swipe-banner-forward",
                onTouchstart: w[4] || (w[4] = (O) => p.swipeToClose === "right" && O.preventDefault())
              }, null, 32)
            ], 32)) : createCommentVNode("", true)
          ], 16), [
            [vShow, unref(f)]
          ])
        ]),
        _: 3
      }, 16, ["appear"])
    ], 38)), [
      [vShow, p.displayDirective !== "show" || unref(V)]
    ]) : createCommentVNode("", true);
  }
});
var Vo = {
  ...fe,
  /**
   * @description Set `null | false` to disable teleport.
   * @default `'body'`
   * @example
   * ```js
   * teleportTo: '#modals'
   * ```
   */
  teleportTo: {
    type: [String, null, Boolean, Object],
    default: "body"
  }
};
var Eo = defineComponent({
  inheritAttrs: false
});
var Bo = defineComponent({
  ...Eo,
  __name: "VueFinalModal",
  props: Vo,
  emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
  setup(e, { emit: o }) {
    const r = xo({
      props: e,
      modalProps: fe,
      emit: o
    });
    return (d, u) => (openBlock(), createBlock(Teleport, {
      to: d.teleportTo ? d.teleportTo : void 0,
      disabled: !d.teleportTo
    }, [
      createVNode(ko, normalizeProps(guardReactiveProps(unref(r))), {
        default: withCtx(() => [
          renderSlot(d.$slots, "default")
        ]),
        _: 3
      }, 16)
    ], 8, ["to", "disabled"]));
  }
});
var R;
var Lo = (e) => R = e;
var Io = () => getCurrentInstance() && inject(pe) || R;
function Yo() {
  const e = shallowReactive([]), o = shallowReactive([]), t = shallowReactive([]), r = shallowReactive([]), d = ref([]), u = markRaw({
    install(s) {
      s.provide(pe, u), s.config.globalProperties.$vfm = u;
      const n = Po(u);
      s.provide(me, n);
    },
    modals: e,
    openedModals: o,
    openedModalOverlays: t,
    dynamicModals: r,
    modalsContainers: d,
    get(s) {
      return e.find((n) => n.value.modalId && s === n.value.modalId);
    },
    toggle(s, n) {
      const l = u.get(s);
      return l == null ? void 0 : l.value.toggle(n);
    },
    open(s) {
      return u.toggle(s, true);
    },
    close(s) {
      return u.toggle(s, false);
    },
    closeAll() {
      return Promise.allSettled([o.map((s) => s.value.toggle(false))]);
    }
  });
  return Lo(u), u;
}
function Po(e) {
  const { modals: o, openedModals: t, openedModalOverlays: r, dynamicModals: d } = e, u = {
    deleteFromModals(s) {
      const n = o.findIndex((l) => l.value === s.value);
      n !== -1 && o.splice(n, 1);
    },
    moveToLastOpenedModals(s) {
      u.deleteFromOpenedModals(s), t.push(s);
    },
    deleteFromOpenedModals(s) {
      const n = t.findIndex((l) => l.value === s.value);
      n !== -1 && t.splice(n, 1);
    },
    moveToLastOpenedModalOverlays(s) {
      u.deleteFromOpenedModalOverlays(s), r.push(s);
    },
    deleteFromOpenedModalOverlays(s) {
      const n = r.findIndex((l) => l.value === s.value);
      n !== -1 && r.splice(n, 1);
    },
    async openLastOverlay() {
      var s;
      if (await nextTick(), r.forEach((n) => n.value.overlayVisible.value = false), r.length > 0) {
        const n = r[r.length - 1];
        !((s = n.value.hideOverlay) != null && s.value) && (n.value.overlayVisible.value = true);
      }
    },
    resolvedClosed(s) {
      var n, l, i;
      (l = (n = d[s]) == null ? void 0 : n.resolveClosed) == null || l.call(n), (i = d[s]) != null && i.keepAlive || d.splice(s, 1);
    },
    resolvedOpened(s) {
      var n, l;
      (l = (n = d[s]) == null ? void 0 : n.resolveOpened) == null || l.call(n);
    }
  };
  return u;
}
function ee() {
  const e = Io();
  if (!e)
    throw new Error(
      `[Vue Final Modal]: getActiveVfm was called with no active Vfm. Did you forget to install vfm?
	const vfm = createVfm()
	app.use(vfm)
This will fail in production.`
    );
  return e;
}
function Ao() {
  return inject(me);
}
function Le(e, o = Bo) {
  const { component: t, slots: r, ...d } = e, u = typeof r > "u" ? {} : Object.fromEntries(Object.entries(r).map(([s, n]) => isString(n) ? [s, n] : "component" in n ? [s, {
    ...n,
    component: markRaw(n.component)
  }] : [s, markRaw(n)]));
  return {
    ...d,
    component: markRaw(t || o),
    slots: u
  };
}
function $o(e) {
  const o = reactive({
    id: Symbol("useModal"),
    modelValue: !!(e != null && e.defaultModelValue),
    resolveOpened: () => {
    },
    resolveClosed: () => {
    },
    attrs: {},
    ...Le(e)
  });
  tryOnUnmounted(() => {
    o != null && o.keepAlive || n();
  }), o.modelValue === true && (R ? R == null || R.dynamicModals.push(o) : nextTick(() => {
    const l = ee();
    l == null || l.dynamicModals.push(o);
  }));
  async function t() {
    let l;
    return R ? l = R : (await nextTick(), l = ee()), o.modelValue ? Promise.resolve("[Vue Final Modal] modal is already opened.") : (n(), o.modelValue = true, l.dynamicModals.push(o), new Promise((i) => {
      o.resolveOpened = () => i("opened");
    }));
  }
  function r() {
    return o.modelValue ? (o.modelValue = false, new Promise((l) => {
      o.resolveClosed = () => l("closed");
    })) : Promise.resolve("[Vue Final Modal] modal is already closed.");
  }
  function d(l) {
    const { slots: i, ...y } = Le(l, o.component);
    l.defaultModelValue !== void 0 && (o.defaultModelValue = l.defaultModelValue), (l == null ? void 0 : l.keepAlive) !== void 0 && (o.keepAlive = l == null ? void 0 : l.keepAlive), u(o, y), i && Object.entries(i).forEach(([c, M]) => {
      const b = o.slots[c];
      isString(b) ? o.slots[c] = M : Ie(b) && Ie(M) ? u(b, M) : o.slots[c] = M;
    });
  }
  function u(l, i) {
    i.component && (l.component = i.component), i.attrs && s(l.attrs, i.attrs);
  }
  function s(l, i) {
    return Object.entries(i).forEach(([y, c]) => {
      l[y] = c;
    }), l;
  }
  function n() {
    const l = ee(), i = l.dynamicModals.indexOf(o);
    i !== -1 && l.dynamicModals.splice(i, 1);
  }
  return {
    options: o,
    open: t,
    close: r,
    patchOptions: d,
    destroy: n
  };
}
function zo(e) {
  return e;
}
function Ie(e) {
  return "component" in e || "attrs" in e;
}
function Do(e, o) {
  return Object.keys(o).reduce((t, r) => (t[r] = e[r], t), {});
}
function Fo(e) {
  return e ? {
    "onUpdate:modelValue": (o) => e("update:modelValue", o),
    onBeforeClose: () => e("beforeClose"),
    onClosed: () => e("closed"),
    onBeforeOpen: () => e("beforeOpen"),
    onOpened: () => e("opened"),
    /** onClickOutside will only be emitted when clickToClose equal to `false` */
    onClickOutside: () => e("clickOutside")
  } : {};
}
function xo(e) {
  const { props: o, modalProps: t, emit: r } = e, d = computed(() => Do(o, t)), u = Fo(r), s = useAttrs();
  return computed(() => ({
    ...d.value,
    ...u,
    ...s
  }));
}
var Ro = ["innerHTML"];
var Go = defineComponent({
  __name: "ModalsContainer",
  setup(e) {
    const o = ee(), t = Ao(), r = Symbol("ModalsContainer"), d = computed(() => {
      var u;
      return r === ((u = o.modalsContainers.value) == null ? void 0 : u[0]);
    });
    return o.modalsContainers.value.push(r), onBeforeUnmount(() => {
      o.modalsContainers.value = o.modalsContainers.value.filter((u) => u !== r);
    }), (u, s) => unref(d) ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(o).dynamicModals, (n, l) => (openBlock(), createBlock(resolveDynamicComponent(n.component), mergeProps({
      key: n.id
    }, {
      displayDirective: n != null && n.keepAlive ? "show" : void 0,
      ...n.attrs
    }, {
      modelValue: n.modelValue,
      "onUpdate:modelValue": (i) => n.modelValue = i,
      onClosed: () => {
        var i, y;
        return (y = (i = unref(t)).resolvedClosed) == null ? void 0 : y.call(i, l);
      },
      onOpened: () => {
        var i, y;
        return (y = (i = unref(t)).resolvedOpened) == null ? void 0 : y.call(i, l);
      }
    }), createSlots({ _: 2 }, [
      renderList(n.slots, (i, y) => ({
        name: y,
        fn: withCtx(() => [
          unref(isString)(i) ? (openBlock(), createElementBlock("div", {
            key: 0,
            innerHTML: i
          }, null, 8, Ro)) : "component" in i ? (openBlock(), createBlock(resolveDynamicComponent(i.component), normalizeProps(mergeProps({ key: 1 }, i.attrs)), null, 16)) : (openBlock(), createBlock(resolveDynamicComponent(i), { key: 2 }))
        ])
      }))
    ]), 1040, ["modelValue", "onUpdate:modelValue", "onClosed", "onOpened"]))), 128)) : createCommentVNode("", true);
  }
});
export {
  ko as CoreModal,
  Go as ModalsContainer,
  Bo as VueFinalModal,
  R as activeVfm,
  fe as coreModalProps,
  Yo as createVfm,
  Io as getActiveVfm,
  Lo as setActiveVfm,
  $o as useModal,
  zo as useModalSlot,
  ee as useVfm,
  xo as useVfmAttrs,
  Vo as vueFinalModalProps
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.1.1
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.4.0
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=vue-final-modal.js.map
