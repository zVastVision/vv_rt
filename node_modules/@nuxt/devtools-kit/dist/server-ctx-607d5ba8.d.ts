import { BirpcGroup } from 'birpc';
import { NuxtOptions, Component, NuxtPage, NuxtLayout, NuxtApp, Nuxt } from 'nuxt/schema';
import { StorageMounts } from 'nitropack';
import { StorageValue } from 'unstorage';
import { VitePluginInspectorOptions } from 'vite-plugin-vue-inspector';
import { VNode } from 'vue';
import { RouteRecordNormalized } from 'vue-router';
import { Import, UnimportMeta } from 'unimport';
import { Options } from 'execa';
import { NuxtAnalyzeMeta } from '@nuxt/schema';

type TabCategory = 'app' | 'analyze' | 'server' | 'modules' | 'documentation' | 'advanced';

interface ModuleCustomTab {
    /**
     * The name of the tab, must be unique
     */
    name: string;
    /**
     * Icon of the tab, support any Iconify icons, or a url to an image
     */
    icon?: string;
    /**
     * Title of the tab
     */
    title: string;
    /**
     * Main view of the tab
     */
    view: ModuleView;
    /**
     * Category of the tab
     * @default 'app'
     */
    category?: TabCategory;
    /**
     * Insert static vnode to the tab entry
     *
     * Advanced options. You don't usually need this.
     */
    extraTabVNode?: VNode;
}
interface ModuleLaunchView {
    /**
     * A view for module to lazy launch some actions
     */
    type: 'launch';
    title?: string;
    icon?: string;
    description: string;
    /**
     * Action buttons
     */
    actions: ModuleLaunchAction[];
}
interface ModuleIframeView {
    /**
     * Iframe view
     */
    type: 'iframe';
    /**
     * Url of the iframe
     */
    src: string;
    /**
     * Persist the iframe instance even if the tab is not active
     *
     * @default true
     */
    persistent?: boolean;
}
interface ModuleVNodeView {
    /**
     * Vue's VNode view
     */
    type: 'vnode';
    /**
     * Send vnode to the client, they must be static and serializable
     *
     * Call `nuxt.hook('devtools:customTabs:refresh')` to trigger manual refresh
     */
    vnode: VNode;
}
interface ModuleLaunchAction {
    /**
     * Label of the action button
     */
    label: string;
    /**
     * Additional HTML attributes to the action button
     */
    attrs?: Record<string, string>;
    /**
     * Indicate if the action is pending, will show a loading indicator and disable the button
     */
    pending?: boolean;
    /**
     * Function to handle the action, this is executed on the server side.
     * Will automatically refresh the tabs after the action is resolved.
     */
    handle?: () => void | Promise<void>;
    /**
     * Treat the action as a link, will open the link in a new tab
     */
    src?: string;
}
type ModuleView = ModuleIframeView | ModuleLaunchView | ModuleVNodeView;
interface ModuleIframeTabLazyOptions {
    description?: string;
    onLoad?: () => Promise<void>;
}
interface ModuleBuiltinTab {
    name: string;
    icon?: string;
    title?: string;
    path?: string;
    category?: TabCategory;
    show?: () => any;
    badge?: () => number | string | undefined;
    onClick?: () => void;
}
type ModuleTabInfo = ModuleCustomTab | ModuleBuiltinTab;

interface ModuleOptions {
    /**
     * Enable DevTools
     *
     * @default true
     */
    enabled?: boolean;
    /**
     * Custom tabs
     *
     * This is in static format, for dynamic injection, call `nuxt.hook('devtools:customTabs')` instead
     */
    customTabs?: ModuleCustomTab[];
    /**
     * VS Code Server integration options.
     */
    vscode?: VSCodeIntegrationOptions;
    /**
     * Enable Vue Component Inspector
     *
     * @default true
     */
    componentInspector?: boolean | VitePluginInspectorOptions;
    /**
     * Enable vite-plugin-inspect
     *
     * @default true
     */
    viteInspect?: boolean;
}
interface ModuleGlobalOptions {
    /**
     * List of projects to enable devtools for. Only works when devtools is installed globally.
     */
    projects?: string[];
}
interface VSCodeIntegrationOptions {
    /**
     * Enable VS Code Server integration
     */
    enabled?: boolean;
    /**
     * Start VS Code Server on boot
     *
     * @default false
     */
    startOnBoot?: boolean;
    /**
     * Port to start VS Code Server
     *
     * @default 3080
     */
    port?: number;
    /**
     * Reuse existing server if available (same port)
     */
    reuseExistingServer?: boolean;
    /**
     * Determine whether to use code-server or vs code tunnel
     *
     * @default 'local-serve'
     */
    mode?: 'local-serve' | 'tunnel';
    /**
     * Options for VS Code tunnel
     */
    tunnel?: VSCodeTunnelOptions;
}
interface VSCodeTunnelOptions {
    /**
     * the machine name for port forwarding service
     *
     * default: device hostname
     */
    name?: string;
}
interface NuxtDevToolsUIOptions {
    componentsView: 'list' | 'graph';
    componentsGraphShowNodeModules: boolean;
    componentsGraphShowPages: boolean;
    componentsGraphShowLayouts: boolean;
    componentsGraphShowWorkspace: boolean;
    interactionCloseOnOutsideClick: boolean;
    showExperimentalFeatures: boolean;
    showHelpButtons: boolean;
    scale: number;
    hiddenTabs: string[];
    hiddenTabCategories: string[];
}

interface HookInfo {
    name: string;
    start: number;
    end?: number;
    duration?: number;
    listeners: number;
    executions: number[];
}
interface ImageMeta {
    width: number;
    height: number;
    orientation?: number;
    type?: string;
    mimeType?: string;
}
interface PackageUpdateInfo {
    name: string;
    current: string;
    latest: string;
    needsUpdate: boolean;
}
type PackageManagerName = 'npm' | 'yarn' | 'pnpm';
type NpmCommandType = 'install' | 'uninstall' | 'update';
interface NpmCommandOptions {
    dev?: boolean;
    global?: boolean;
}
interface AutoImportsWithMetadata {
    imports: Import[];
    metadata?: UnimportMeta;
    dirs: string[];
}
interface RouteInfo extends Pick<RouteRecordNormalized, 'name' | 'path' | 'meta' | 'props' | 'children'> {
    file?: string;
}
interface ServerRouteInfo {
    route: string;
    filepath: string;
    path: string;
    method?: string;
    type: 'api' | 'route';
}
interface Payload {
    url: string;
    time: number;
    data?: Record<string, any>;
    state?: Record<string, any>;
    functions?: Record<string, any>;
}
interface PluginInfoWithMetic {
    src: string;
    mode?: 'client' | 'server' | 'all';
    ssr?: boolean;
    metric?: PluginMetric;
}
interface PluginMetric {
    src: string;
    start: number;
    end: number;
    duration: number;
}
interface BasicModuleInfo {
    entryPath?: string;
    meta?: {
        name?: string;
    };
}
interface InstalledModuleInfo {
    name?: string;
    isPackageModule: boolean;
    isUninstallable: boolean;
    info?: ModuleStaticInfo;
    entryPath?: string;
    meta?: {
        name?: string;
    };
}
interface ModuleStaticInfo {
    name: string;
    description: string;
    repo: string;
    npm: string;
    icon?: string;
    github: string;
    website: string;
    learn_more: string;
    category: string;
    type: ModuleType;
    maintainers: MaintainerInfo[];
    contributors: GitHubContributor[];
    compatibility: ModuleCompatibility;
}
interface ModuleCompatibility {
    nuxt: string;
    requires: {
        bridge?: boolean | 'optional';
    };
}
type CompatibilityStatus = 'working' | 'wip' | 'unknown' | 'not-working';
type ModuleType = 'community' | 'official' | '3rd-party';
interface MaintainerInfo {
    name: string;
    github: string;
    twitter?: string;
}
interface GitHubContributor {
    login: string;
    name?: string;
    avatar_url?: string;
}
interface VueInspectorClient {
    enabled: boolean;
    position: {
        x: number;
        y: number;
    };
    linkParams: {
        file: string;
        line: number;
        column: number;
    };
    enable: () => void;
    disable: () => void;
    toggleEnabled: () => void;
    openInEditor: (baseUrl: string, file: string, line: number, column: number) => void;
    onUpdated: () => void;
}
type VueInspectorData = VueInspectorClient['linkParams'] & VueInspectorClient['position'];
type AssetType = 'image' | 'font' | 'video' | 'audio' | 'text' | 'json' | 'other';
interface AssetInfo {
    path: string;
    type: AssetType;
    publicPath: string;
    filePath: string;
    size: number;
    mtime: number;
}
interface CodeSnippet {
    code: string;
    lang: string;
    name: string;
    docs?: string;
}
interface ComponentRelationship {
    id: string;
    deps: string[];
}

interface TerminalBase {
    id: string;
    name: string;
    description?: string;
    icon?: string;
}
type TerminalAction = 'restart' | 'terminate' | 'clear' | 'remove';
interface SubprocessOptions extends Options {
    command: string;
    args?: string[];
}
interface TerminalInfo extends TerminalBase {
    /**
     * Whether the terminal can be restarted
     */
    restartable?: boolean;
    /**
     * Whether the terminal can be terminated
     */
    terminatable?: boolean;
    /**
     * Whether the terminal is terminated
     */
    isTerminated?: boolean;
    /**
     * Content buffer
     */
    buffer?: string;
}
interface TerminalState extends TerminalInfo {
    /**
     * User action to restart the terminal, when not provided, this action will be disabled
     */
    onActionRestart?: () => Promise<void> | void;
    /**
     * User action to terminate the terminal, when not provided, this action will be disabled
     */
    onActionTerminate?: () => Promise<void> | void;
}

interface WizardFunctions {
    enablePages: (nuxt: any) => Promise<void>;
}
type WizardActions = keyof WizardFunctions;
type GetWizardArgs<T extends WizardActions> = WizardFunctions[T] extends (nuxt: any, ...args: infer A) => any ? A : never;

interface AnalyzeBuildMeta extends NuxtAnalyzeMeta {
    features: {
        bundleClient: boolean;
        bundleNitro: boolean;
        viteInspect: boolean;
    };
    size: {
        clientBundle?: number;
        nitroBundle?: number;
    };
}
interface AnalyzeBuildsInfo {
    isBuilding: boolean;
    builds: AnalyzeBuildMeta[];
}

interface ServerFunctions {
    getServerConfig(): NuxtOptions;
    getComponents(): Component[];
    getComponentsRelationships(): Promise<ComponentRelationship[]>;
    getAutoImports(): AutoImportsWithMetadata;
    getServerPages(): NuxtPage[];
    getCustomTabs(): ModuleCustomTab[];
    getServerHooks(): HookInfo[];
    getServerLayouts(): NuxtLayout[];
    getStaticAssets(): Promise<AssetInfo[]>;
    getServerRoutes(): Promise<ServerRouteInfo[]>;
    getServerApp(): NuxtApp | undefined;
    getUIOptions(): Promise<NuxtDevToolsUIOptions>;
    updateUIOptions(settings: Partial<NuxtDevToolsUIOptions>): Promise<void>;
    checkForUpdateFor(name: string): Promise<PackageUpdateInfo | undefined>;
    getPackageManager(): Promise<PackageManagerName>;
    getNpmCommand(command: NpmCommandType, packageName: string, options?: NpmCommandOptions): Promise<string[] | undefined>;
    runNpmCommand(command: NpmCommandType, packageName: string, options?: NpmCommandOptions): Promise<{
        processId: string;
    } | undefined>;
    getTerminals(): TerminalInfo[];
    getTerminalDetail(id: string): TerminalInfo | undefined;
    runTerminalAction(id: string, action: TerminalAction): Promise<boolean>;
    getStorageMounts(): Promise<StorageMounts>;
    getStorageKeys(base?: string): Promise<string[]>;
    getStorageItem(key: string): Promise<StorageValue>;
    setStorageItem(key: string, value: StorageValue): Promise<void>;
    removeStorageItem(key: string): Promise<void>;
    getAnalyzeBuildInfo(): Promise<AnalyzeBuildsInfo>;
    generateAnalyzeBuildName(): Promise<string>;
    startAnalyzeBuild(name: string): Promise<string>;
    clearAnalyzeBuilds(names?: string[]): Promise<void>;
    getImageMeta(filepath: string): Promise<ImageMeta | undefined>;
    getTextAssetContent(filepath: string, limit?: number): Promise<string | undefined>;
    writeStaticAssets(file: {
        name: string;
        data: string;
    }[], path: string): Promise<string[]>;
    customTabAction(name: string, action: number): Promise<boolean>;
    runWizard<T extends WizardActions>(name: T, ...args: GetWizardArgs<T>): Promise<void>;
    openInEditor(filepath: string): Promise<boolean>;
    restartNuxt(hard?: boolean): Promise<void>;
    installNuxtModule(name: string, dry?: boolean): Promise<InstallModuleReturn>;
    uninstallNuxtModule(name: string, dry?: boolean): Promise<InstallModuleReturn>;
}
interface ClientFunctions {
    refresh(event: ClientUpdateEvent): void;
    callHook(hook: string, ...args: any[]): Promise<void>;
    navigateTo(path: string): void;
    onTerminalData(_: {
        id: string;
        data: string;
    }): void;
    onTerminalExit(_: {
        id: string;
        code?: number;
    }): void;
}
type ClientUpdateEvent = keyof ServerFunctions;

/**
 * @internal
 */
interface NuxtDevtoolsServerContext {
    nuxt: Nuxt;
    options: ModuleOptions;
    rpc: BirpcGroup<ClientFunctions, ServerFunctions>;
    /**
     * Hook to open file in editor
     */
    openInEditorHooks: ((filepath: string) => boolean | void | Promise<boolean | void>)[];
    /**
     * Invalidate client cache for a function and ask for re-fetching
     */
    refresh: (event: keyof ServerFunctions) => void;
    extendServerRpc: <ClientFunctions = {}, ServerFunctions = {}>(name: string, functions: ServerFunctions) => BirpcGroup<ClientFunctions, ServerFunctions>;
}
interface NuxtDevtoolsInfo {
    version: string;
    packagePath: string;
    isGlobalInstall: boolean;
}
interface InstallModuleReturn {
    configOriginal: string;
    configGenerated: string;
    commands: string[];
    processId: string;
}

export { VSCodeIntegrationOptions as $, AutoImportsWithMetadata as A, BasicModuleInfo as B, CompatibilityStatus as C, CodeSnippet as D, ComponentRelationship as E, WizardActions as F, GitHubContributor as G, HookInfo as H, ImageMeta as I, GetWizardArgs as J, ServerFunctions as K, ClientFunctions as L, ModuleCustomTab as M, NuxtDevtoolsInfo as N, ClientUpdateEvent as O, PackageUpdateInfo as P, NuxtDevtoolsServerContext as Q, RouteInfo as R, SubprocessOptions as S, TerminalState as T, InstallModuleReturn as U, VueInspectorClient as V, WizardFunctions as W, AnalyzeBuildMeta as X, AnalyzeBuildsInfo as Y, ModuleOptions as Z, ModuleGlobalOptions as _, ModuleLaunchView as a, VSCodeTunnelOptions as a0, NuxtDevToolsUIOptions as a1, TabCategory as a2, ModuleIframeView as b, ModuleVNodeView as c, ModuleLaunchAction as d, ModuleView as e, ModuleIframeTabLazyOptions as f, ModuleBuiltinTab as g, ModuleTabInfo as h, TerminalBase as i, TerminalAction as j, TerminalInfo as k, PackageManagerName as l, NpmCommandType as m, NpmCommandOptions as n, ServerRouteInfo as o, Payload as p, PluginInfoWithMetic as q, PluginMetric as r, InstalledModuleInfo as s, ModuleStaticInfo as t, ModuleCompatibility as u, ModuleType as v, MaintainerInfo as w, VueInspectorData as x, AssetType as y, AssetInfo as z };
