import { ref as E, computed as C, watch as P, nextTick as Z, onBeforeUnmount as de, reactive as ie, onMounted as Pe, defineComponent as se, inject as oe, toRef as Ze, unref as m, withDirectives as Te, openBlock as I, createElementBlock as j, normalizeClass as Me, normalizeStyle as Se, withKeys as Ke, withModifiers as Oe, createBlock as G, Transition as Ce, mergeProps as W, toHandlers as ge, withCtx as ne, createCommentVNode as z, createVNode as Ae, createElementVNode as $, renderSlot as ue, vShow as ke, Teleport as qe, normalizeProps as De, guardReactiveProps as Je, getCurrentInstance as Qe, shallowReactive as q, markRaw as Q, useAttrs as _e, Fragment as eo, renderList as Ve, resolveDynamicComponent as ae, createSlots as oo } from "vue";
import { useEventListener as x, tryOnUnmounted as no, isString as ce } from "@vueuse/core";
import { useFocusTrap as to } from "@vueuse/integrations/useFocusTrap";
const fe = {
  /**
   * @description An uniq name for the open/close a modal via vfm.open/vfm.close APIs.
   * @default `undefined`
   * @example Symbol: `Symbol('MyModal')`
   * @example String: `'AUniqString'`
   * @example Number: `300`
   */
  modalId: {
    type: [String, Number, Symbol],
    default: void 0
  },
  /**
   * @description Display the modal or not.
   * @default `undefined`
   * @example
   * ```js
   * const showModal = ref(false)
   * v-model="showModal"
   * ```
   */
  modelValue: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Render the modal via `if` or `show`.
   * @default `'if'`
   * @example
   * ```js
   * displayDirective: 'if'
   * ```
   * @example
   * ```js
   * displayDirective: 'show'
   * ```
   */
  displayDirective: {
    type: String,
    default: "if",
    validator: (e) => ["if", "show"].includes(e)
  },
  /**
   * @description Hide the overlay or not.
   * @default `undefined`
   * @example
   * ```js
   * hideOverlay="true"
   * ```
   */
  hideOverlay: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Customize the overlay transition.
   * @default `undefined`
   */
  overlayTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Customize the content transition.
   * @default `undefined`
   */
  contentTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Bind class to vfm__overlay.
   * @default `undefined`
   */
  overlayClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind class to vfm__content.
   * @default `undefined`
   */
  contentClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind style to vfm__overlay.
   * @default `undefined`
   */
  overlayStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Bind style to vfm__content.
   * @default `undefined`
   */
  contentStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Is it allow to close the modal by clicking the overlay.
   * @default `true`
   */
  clickToClose: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Is it allow to close the modal by keypress `esc`.
   * @default `true`
   */
  escToClose: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Is it allow to click outside of the vfm__content when the modal is opened
   * @default `'non-interactive'`
   */
  background: {
    type: String,
    default: "non-interactive",
    validator: (e) => ["interactive", "non-interactive"].includes(e)
  },
  /**
   * @description
   * * Use `{ disabled: true }` to disable the focusTrap.
   * * Checkout the createOptions type here https://github.com/focus-trap/focus-trap for more.
   * @default `{ allowOutsideClick: true }`
   */
  focusTrap: {
    type: [Boolean, Object],
    default: () => ({
      allowOutsideClick: !0
    })
  },
  /**
   * @description Lock body scroll or not when the modal is opened.
   * @default `true`
   */
  lockScroll: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Define how to increase the zIndex when there are nested modals
   * @default `({ index }) => 1000 + 2 * index`
   */
  zIndexFn: {
    type: Function,
    default: ({ index: e }) => 1e3 + 2 * e
  },
  /**
   * @description The direction of swiping to close the modal
   * @default `none`
   * @example
   * Set swipeToClose="none" to disable swiping to close
   * ```js
   * swipeToClose="none"
   * ```
   */
  swipeToClose: {
    type: String,
    default: "none",
    validator: (e) => ["none", "up", "right", "down", "left"].includes(e)
  },
  /**
   * @description Threshold for swipe to close
   * @default `0`
   */
  threshold: {
    type: Number,
    default: 0
  },
  /**
   * @description If set `:showSwipeBanner="true"`, only allow clicking `swipe-banner` slot to swipe to close
   * @default `undefined`
   * @example
   * ```js
   * swipeToClose="right"
   * :showSwipeBanner="true"
   * ```
   * ```html
   * <VueFinalModal
   *   ...
   *   swipeToClose="right"
   *   :showSwipeBanner="true"
   * >
   *   <template #swipe-banner>
   *     <div style="position: absolute; height: 100%; top: 0; left: 0; width: 10px;" />
   *   </template>
   *   ...modal content
   * </VueFinalModal>
   * ```
   */
  showSwipeBanner: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description When set `:preventNavigationGestures="true"`, there will be two invisible bars for prevent navigation gestures including swiping back/forward on mobile webkit. For example: Safari mobile.
   * @default `undefined`
   * @example
   * Set preventNavigationGestures="true" to prevent Safari navigation gestures including swiping back/forward.
   * ```js
   * :preventNavigationGestures="true"
   * ```
   */
  preventNavigationGestures: {
    type: Boolean,
    default: void 0
  }
};
function Ee(e = !1) {
  const o = E(e), t = E(o.value ? 0 : void 0);
  return [o, t, {
    beforeEnter() {
      t.value = 1;
    },
    afterEnter() {
      t.value = 0;
    },
    beforeLeave() {
      t.value = 3;
    },
    afterLeave() {
      t.value = 2;
    }
  }];
}
function lo(e, o) {
  const { modelValueLocal: t, onEntering: r, onEnter: d, onLeaving: u, onLeave: s } = o, n = E(t.value), [l, i, y] = Ee(n.value), [c, M, b] = Ee(n.value), g = C(() => typeof e.contentTransition == "string" ? { name: e.contentTransition } : { ...e.contentTransition }), B = C(() => typeof e.overlayTransition == "string" ? { name: e.overlayTransition } : { ...e.overlayTransition }), k = C(
    () => (e.hideOverlay || M.value === 2) && i.value === 2
    /* Leave */
  );
  P(
    k,
    (L) => {
      L && (n.value = !1);
    }
  ), P(i, (L) => {
    switch (L) {
      case 1:
        return r == null ? void 0 : r();
      case 0:
        return d == null ? void 0 : d();
      case 3:
        return u == null ? void 0 : u();
      case 2:
        return s == null ? void 0 : s();
    }
  });
  async function T() {
    n.value = !0, await Z(), l.value = !0, c.value = !0;
  }
  function S() {
    l.value = !1, c.value = !1;
  }
  return {
    visible: n,
    contentVisible: l,
    contentListeners: y,
    contentTransition: g,
    overlayVisible: c,
    overlayListeners: b,
    overlayTransition: B,
    enterTransition: T,
    leaveTransition: S
  };
}
function so(e, o, t) {
  const { vfmRootEl: r, vfmContentEl: d, visible: u, modelValueLocal: s } = t, n = E();
  function l() {
    u.value && e.escToClose && (s.value = !1);
  }
  function i(c) {
    n.value = c == null ? void 0 : c.target;
  }
  function y() {
    var c;
    n.value === r.value && (e.clickToClose ? s.value = !1 : ((c = d.value) == null || c.focus(), o("clickOutside")));
  }
  return {
    onEsc: l,
    onMouseupRoot: y,
    onMousedown: i
  };
}
function ro(e, o) {
  const t = E(!!e.modelValue);
  return P(() => e.modelValue, (r) => {
    t.value = !!r;
  }), P(t, (r) => {
    r !== e.modelValue && o("update:modelValue", r);
  }), {
    modelValueLocal: t
  };
}
function ao(e, o) {
  if (e.focusTrap === !1)
    return {
      focus() {
      },
      blur() {
      }
    };
  const { focusEl: t } = o, { hasFocus: r, activate: d, deactivate: u } = to(t, e.focusTrap);
  function s() {
    requestAnimationFrame(() => {
      d();
    });
  }
  function n() {
    r.value && u();
  }
  return { focus: s, blur: n };
}
let ve = !1;
if (typeof window < "u") {
  const e = {
    get passive() {
      ve = !0;
    }
  };
  window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e);
}
const Fe = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
let H = [], te = !1, _ = 0, xe = -1, X, U;
const io = (e) => {
  if (!e || e.nodeType !== Node.ELEMENT_NODE)
    return !1;
  const o = window.getComputedStyle(e);
  return ["auto", "scroll"].includes(o.overflowY) && e.scrollHeight > e.clientHeight;
}, uo = (e, o) => !(e.scrollTop === 0 && o < 0 || e.scrollTop + e.clientHeight + o >= e.scrollHeight && o > 0), co = (e) => {
  const o = [];
  for (; e; ) {
    if (o.push(e), e.classList.contains("vfm"))
      return o;
    e = e.parentElement;
  }
  return o;
}, fo = (e, o) => {
  let t = !1;
  return co(e).forEach((d) => {
    io(d) && uo(d, o) && (t = !0);
  }), t;
}, Re = (e) => H.some(() => fo(e, -_)), le = (e) => {
  const o = e || window.event;
  return Re(o.target) || o.touches.length > 1 ? !0 : (o.preventDefault && o.preventDefault(), !1);
}, vo = (e) => {
  if (U === void 0) {
    const o = !!e && e.reserveScrollBarGap === !0, t = window.innerWidth - document.documentElement.clientWidth;
    if (o && t > 0) {
      const r = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
      U = document.body.style.paddingRight, document.body.style.paddingRight = `${r + t}px`;
    }
  }
  X === void 0 && (X = document.body.style.overflow, document.body.style.overflow = "hidden");
}, po = () => {
  U !== void 0 && (document.body.style.paddingRight = U, U = void 0), X !== void 0 && (document.body.style.overflow = X, X = void 0);
}, mo = (e) => e ? e.scrollHeight - e.scrollTop <= e.clientHeight : !1, yo = (e, o) => (_ = e.targetTouches[0].clientY - xe, Re(e.target) ? !1 : o && o.scrollTop === 0 && _ > 0 || mo(o) && _ < 0 ? le(e) : (e.stopPropagation(), !0)), ho = (e, o) => {
  if (!e) {
    console.error(
      "disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."
    );
    return;
  }
  if (H.some((r) => r.targetElement === e))
    return;
  const t = {
    targetElement: e,
    options: o || {}
  };
  H = [...H, t], Fe ? (e.ontouchstart = (r) => {
    r.targetTouches.length === 1 && (xe = r.targetTouches[0].clientY);
  }, e.ontouchmove = (r) => {
    r.targetTouches.length === 1 && yo(r, e);
  }, te || (document.addEventListener("touchmove", le, ve ? { passive: !1 } : void 0), te = !0)) : vo(o);
}, wo = (e) => {
  if (!e) {
    console.error(
      "enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices."
    );
    return;
  }
  H = H.filter((o) => o.targetElement !== e), Fe ? (e.ontouchstart = null, e.ontouchmove = null, te && H.length === 0 && (document.removeEventListener("touchmove", le, ve ? { passive: !1 } : void 0), te = !1)) : H.length || po();
};
function bo(e, o) {
  const { lockScrollEl: t, modelValueLocal: r } = o;
  let d;
  P(t, (n) => {
    n && (d = n);
  }, { immediate: !0 }), P(() => e.lockScroll, (n) => {
    n ? s() : u();
  }), de(() => {
    u();
  });
  function u() {
    d && wo(d);
  }
  function s() {
    r.value && e.lockScroll && d && ho(d, {
      reserveScrollBarGap: !0,
      allowTouchMove: (n) => {
        for (; n && n !== document.body; ) {
          if (n.getAttribute("vfm-scroll-lock-ignore") !== null)
            return !0;
          n = n.parentElement;
        }
        return !1;
      }
    });
  }
  return {
    enableBodyScroll: u,
    disableBodyScroll: s
  };
}
function To(e) {
  function o(t) {
    switch (t) {
      case "beforeOpen":
        e(t);
        break;
      case "beforeClose":
        e(t);
        break;
      case "opened":
        e(t);
        break;
      case "closed":
        e(t);
        break;
    }
  }
  return {
    emitEvent: o
  };
}
function Mo(e) {
  const o = E();
  function t(d) {
    var u;
    o.value = (u = e.zIndexFn) == null ? void 0 : u.call(e, { index: d <= -1 ? 0 : d });
  }
  function r() {
    o.value = void 0;
  }
  return {
    zIndex: o,
    refreshZIndex: t,
    resetZIndex: r
  };
}
const So = (e) => (...o) => {
  e && (e == null || e(...o), e = null);
}, A = () => {
};
function J(e, o, t) {
  return e > t ? t : e < o ? o : e;
}
const Be = (e) => {
  if (e instanceof MouseEvent) {
    const { clientX: o, clientY: t } = e;
    return { x: o, y: t };
  } else {
    const { clientX: o, clientY: t } = e.targetTouches[0];
    return { x: o, y: t };
  }
};
function Oo(e) {
  if (!e)
    return !1;
  let o = !1;
  const t = {
    get passive() {
      return o = !0, !1;
    }
  };
  return e.addEventListener("x", A, t), e.removeEventListener("x", A), o;
}
function Co(e, {
  threshold: o = 0,
  onSwipeStart: t,
  onSwipe: r,
  onSwipeEnd: d,
  passive: u = !0
}) {
  const s = ie({ x: 0, y: 0 }), n = ie({ x: 0, y: 0 }), l = C(() => s.x - n.x), i = C(() => s.y - n.y), { max: y, abs: c } = Math, M = C(
    () => y(c(l.value), c(i.value)) >= o
  ), b = E(!1), g = C(() => M.value ? c(l.value) > c(i.value) ? l.value > 0 ? "left" : "right" : i.value > 0 ? "up" : "down" : "none"), B = (f, h) => {
    s.x = f, s.y = h;
  }, k = (f, h) => {
    n.x = f, n.y = h;
  };
  let T, S;
  function L(f) {
    T.capture && !T.passive && f.preventDefault();
    const { x: h, y: F } = Be(f);
    B(h, F), k(h, F), t == null || t(f), S = [
      x(e, "mousemove", N, T),
      x(e, "touchmove", N, T),
      x(e, "mouseup", a, T),
      x(e, "touchend", a, T),
      x(e, "touchcancel", a, T)
    ];
  }
  function N(f) {
    const { x: h, y: F } = Be(f);
    k(h, F), !b.value && M.value && (b.value = !0), b.value && (r == null || r(f));
  }
  function a(f) {
    b.value && (d == null || d(f, g.value)), b.value = !1, S.forEach((h) => h());
  }
  let v = [];
  return Pe(() => {
    const f = Oo(window == null ? void 0 : window.document);
    u ? T = f ? { passive: !0 } : { capture: !1 } : T = f ? { passive: !1, capture: !0 } : { capture: !0 }, v = [
      x(e, "mousedown", L, T),
      x(e, "touchstart", L, T)
    ];
  }), {
    isSwiping: b,
    direction: g,
    coordsStart: s,
    coordsEnd: n,
    lengthX: l,
    lengthY: i,
    stop: () => {
      v.forEach((f) => f()), S.forEach((f) => f());
    }
  };
}
function go(e, o) {
  const { vfmContentEl: t, modelValueLocal: r } = o, d = 0.1, u = 300, s = E(), n = C(() => {
    if (!(e.swipeToClose === void 0 || e.swipeToClose === "none"))
      return e.showSwipeBanner ? s.value : t.value;
  }), l = E(0), i = E(!0);
  let y = A, c = !0, M, b = !1;
  const { lengthX: g, lengthY: B, direction: k, isSwiping: T } = Co(n, {
    threshold: e.threshold,
    onSwipeStart(a) {
      y = x(document, "selectionchange", () => {
        var v;
        i.value = (v = window.getSelection()) == null ? void 0 : v.isCollapsed;
      }), M = new Date().getTime(), b = N(a == null ? void 0 : a.target);
    },
    onSwipe() {
      var a, v, V, f;
      if (b && i.value && k.value === e.swipeToClose) {
        if (k.value === "up") {
          const h = J(Math.abs(B.value || 0), 0, ((a = n.value) == null ? void 0 : a.offsetHeight) || 0) - (e.threshold || 0);
          l.value = h;
        } else if (k.value === "down") {
          const h = J(Math.abs(B.value || 0), 0, ((v = n.value) == null ? void 0 : v.offsetHeight) || 0) - (e.threshold || 0);
          l.value = -h;
        } else if (k.value === "right") {
          const h = J(Math.abs(g.value || 0), 0, ((V = n.value) == null ? void 0 : V.offsetWidth) || 0) - (e.threshold || 0);
          l.value = -h;
        } else if (k.value === "left") {
          const h = J(Math.abs(g.value || 0), 0, ((f = n.value) == null ? void 0 : f.offsetWidth) || 0) - (e.threshold || 0);
          l.value = h;
        }
      }
    },
    onSwipeEnd(a, v) {
      if (y(), !i.value) {
        i.value = !0;
        return;
      }
      const V = new Date().getTime(), f = v === e.swipeToClose, h = (() => {
        var Y, K;
        if (v === "up" || v === "down")
          return Math.abs((B == null ? void 0 : B.value) || 0) > d * (((Y = n.value) == null ? void 0 : Y.offsetHeight) || 0);
        if (v === "left" || v === "right")
          return Math.abs((g == null ? void 0 : g.value) || 0) > d * (((K = n.value) == null ? void 0 : K.offsetWidth) || 0);
      })(), F = V - M <= u;
      if (c && b && f && (h || F)) {
        r.value = !1;
        return;
      }
      l.value = 0;
    }
  }), S = C(() => {
    if (e.swipeToClose === "none")
      return;
    const a = (() => {
      switch (e.swipeToClose) {
        case "up":
        case "down":
          return "translateY";
        case "left":
        case "right":
          return "translateX";
      }
    })();
    return {
      class: { "vfm-bounce-back": !T.value },
      style: { transform: `${a}(${-l.value}px)` }
    };
  });
  P(
    () => i.value,
    (a) => {
      a || (l.value = 0);
    }
  ), P(
    () => r.value,
    (a) => {
      a && (l.value = 0);
    }
  ), P(
    () => l.value,
    (a, v) => {
      switch (e.swipeToClose) {
        case "down":
        case "right":
          c = a < v;
          break;
        case "up":
        case "left":
          c = a > v;
          break;
      }
    }
  );
  function L(a) {
    e.preventNavigationGestures && a.preventDefault();
  }
  function N(a) {
    const v = a == null ? void 0 : a.tagName;
    if (!v || ["INPUT", "TEXTAREA"].includes(v))
      return !1;
    const V = (() => {
      switch (e.swipeToClose) {
        case "up":
          return (a == null ? void 0 : a.scrollTop) + (a == null ? void 0 : a.clientHeight) === (a == null ? void 0 : a.scrollHeight);
        case "left":
          return (a == null ? void 0 : a.scrollLeft) + (a == null ? void 0 : a.clientWidth) === (a == null ? void 0 : a.scrollWidth);
        case "down":
          return (a == null ? void 0 : a.scrollTop) === 0;
        case "right":
          return (a == null ? void 0 : a.scrollLeft) === 0;
        default:
          return !1;
      }
    })();
    return a === n.value ? V : V && N(a == null ? void 0 : a.parentElement);
  }
  return {
    vfmContentEl: t,
    swipeBannerEl: s,
    bindSwipe: S,
    onTouchStartSwipeBanner: L
  };
}
const pe = Symbol("vfm"), me = Symbol("internalVfm"), ko = /* @__PURE__ */ se({
  __name: "CoreModal",
  props: fe,
  emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
  setup(e, { emit: o }) {
    const t = e, { modals: r, openedModals: d } = oe(pe, {
      modals: [],
      openedModals: []
    }), {
      openLastOverlay: u,
      moveToLastOpenedModals: s,
      deleteFromOpenedModals: n,
      moveToLastOpenedModalOverlays: l,
      deleteFromOpenedModalOverlays: i,
      deleteFromModals: y
    } = oe(me, {
      openLastOverlay: A,
      moveToLastOpenedModals: A,
      deleteFromOpenedModals: A,
      moveToLastOpenedModalOverlays: A,
      deleteFromOpenedModalOverlays: A,
      deleteFromModals: A
    }), c = E(), M = E(), { focus: b, blur: g } = ao(t, { focusEl: c }), { zIndex: B, refreshZIndex: k, resetZIndex: T } = Mo(t), { modelValueLocal: S } = ro(t, o), { enableBodyScroll: L, disableBodyScroll: N } = bo(t, {
      lockScrollEl: c,
      modelValueLocal: S
    }), { emitEvent: a } = To(o);
    let v = A;
    const {
      visible: V,
      contentVisible: f,
      contentListeners: h,
      contentTransition: F,
      overlayVisible: Y,
      overlayListeners: K,
      overlayTransition: He,
      enterTransition: Ne,
      leaveTransition: je
    } = lo(t, {
      modelValueLocal: S,
      onEntering() {
        Z(() => {
          N();
        });
      },
      onEnter() {
        b(), a("opened"), v("opened");
      },
      onLeave() {
        n(We()), T(), L(), a("closed"), v("closed");
      }
    }), { onEsc: Ye, onMouseupRoot: $e, onMousedown: ye } = so(t, o, { vfmRootEl: c, vfmContentEl: M, visible: V, modelValueLocal: S }), {
      swipeBannerEl: ze,
      bindSwipe: Ge,
      onTouchStartSwipeBanner: he
    } = go(t, { vfmContentEl: M, modelValueLocal: S }), we = Ze(t, "hideOverlay"), D = C(() => ({
      modalId: t.modalId,
      hideOverlay: we,
      overlayVisible: Y,
      focus: b,
      toggle(p) {
        return new Promise((w) => {
          v = So((Ue) => w(Ue));
          const O = typeof p == "boolean" ? p : !S.value;
          S.value = O, o("update:modelValue", O);
        });
      }
    }));
    function We() {
      return D;
    }
    const re = C(() => d.indexOf(D));
    P(() => [t.zIndexFn, re.value], () => {
      V.value && k(re.value);
    }), Pe(() => {
      r.push(D);
    }), S.value && be(), P(S, (p) => {
      p ? be() : Xe();
    });
    async function be() {
      a("beforeOpen"), s(D), l(D), k(re.value), u(), Ne();
    }
    function Xe() {
      a("beforeClose"), i(D), u(), g(), je();
    }
    return de(() => {
      L(), y(D), n(D), i(D), g(), u();
    }), (p, w) => p.displayDirective !== "if" || m(V) ? Te((I(), j("div", {
      key: 0,
      ref_key: "vfmRootEl",
      ref: c,
      class: Me(["vfm vfm--fixed vfm--inset", { "vfm--prevent-none": p.background === "interactive" }]),
      style: Se({ zIndex: m(B) }),
      role: "dialog",
      "aria-modal": "true",
      onKeydown: w[7] || (w[7] = Ke(() => m(Ye)(), ["esc"])),
      onMouseup: w[8] || (w[8] = Oe(() => m($e)(), ["self"])),
      onMousedown: w[9] || (w[9] = Oe((O) => m(ye)(O), ["self"]))
    }, [
      m(we) ? z("", !0) : (I(), G(Ce, W({ key: 0 }, m(He), {
        appear: p.displayDirective === "if"
      }, ge(m(K))), {
        default: ne(() => [
          m(Y) ? (I(), j("div", {
            key: 0,
            class: Me(["vfm__overlay vfm--overlay vfm--absolute vfm--inset vfm--prevent-none", p.overlayClass]),
            style: Se(p.overlayStyle),
            "aria-hidden": "true"
          }, null, 6)) : z("", !0)
        ]),
        _: 1
      }, 16, ["appear"])),
      Ae(Ce, W(m(F), {
        appear: p.displayDirective === "if"
      }, ge(m(h))), {
        default: ne(() => [
          Te($("div", W({
            ref_key: "vfmContentEl",
            ref: M,
            class: ["vfm__content vfm--outline-none", [p.contentClass, { "vfm--prevent-auto": p.background === "interactive" }]],
            style: p.contentStyle,
            tabindex: "0"
          }, m(Ge), {
            onMousedown: w[6] || (w[6] = () => m(ye)())
          }), [
            ue(p.$slots, "default"),
            p.showSwipeBanner ? (I(), j("div", {
              key: 0,
              ref_key: "swipeBannerEl",
              ref: ze,
              class: "vfm-swipe-banner-container",
              onTouchstart: w[2] || (w[2] = (O) => m(he)(O))
            }, [
              ue(p.$slots, "swipe-banner", {}, () => [
                $("div", {
                  class: "vfm-swipe-banner-back",
                  onTouchstart: w[0] || (w[0] = (O) => p.swipeToClose === "left" && O.preventDefault())
                }, null, 32),
                $("div", {
                  class: "vfm-swipe-banner-forward",
                  onTouchstart: w[1] || (w[1] = (O) => p.swipeToClose === "right" && O.preventDefault())
                }, null, 32)
              ])
            ], 544)) : !p.showSwipeBanner && p.preventNavigationGestures ? (I(), j("div", {
              key: 1,
              class: "vfm-swipe-banner-container",
              onTouchstart: w[5] || (w[5] = (O) => m(he)(O))
            }, [
              $("div", {
                class: "vfm-swipe-banner-back",
                onTouchstart: w[3] || (w[3] = (O) => p.swipeToClose === "left" && O.preventDefault())
              }, null, 32),
              $("div", {
                class: "vfm-swipe-banner-forward",
                onTouchstart: w[4] || (w[4] = (O) => p.swipeToClose === "right" && O.preventDefault())
              }, null, 32)
            ], 32)) : z("", !0)
          ], 16), [
            [ke, m(f)]
          ])
        ]),
        _: 3
      }, 16, ["appear"])
    ], 38)), [
      [ke, p.displayDirective !== "show" || m(V)]
    ]) : z("", !0);
  }
});
const Vo = {
  ...fe,
  /**
   * @description Set `null | false` to disable teleport.
   * @default `'body'`
   * @example
   * ```js
   * teleportTo: '#modals'
   * ```
   */
  teleportTo: {
    type: [String, null, Boolean, Object],
    default: "body"
  }
}, Eo = se({
  inheritAttrs: !1
}), Bo = /* @__PURE__ */ se({
  ...Eo,
  __name: "VueFinalModal",
  props: Vo,
  emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
  setup(e, { emit: o }) {
    const r = xo({
      props: e,
      modalProps: fe,
      emit: o
    });
    return (d, u) => (I(), G(qe, {
      to: d.teleportTo ? d.teleportTo : void 0,
      disabled: !d.teleportTo
    }, [
      Ae(ko, De(Je(m(r))), {
        default: ne(() => [
          ue(d.$slots, "default")
        ]),
        _: 3
      }, 16)
    ], 8, ["to", "disabled"]));
  }
});
let R;
const Lo = (e) => R = e, Io = () => Qe() && oe(pe) || R;
function Yo() {
  const e = q([]), o = q([]), t = q([]), r = q([]), d = E([]), u = Q({
    install(s) {
      s.provide(pe, u), s.config.globalProperties.$vfm = u;
      const n = Po(u);
      s.provide(me, n);
    },
    modals: e,
    openedModals: o,
    openedModalOverlays: t,
    dynamicModals: r,
    modalsContainers: d,
    get(s) {
      return e.find((n) => n.value.modalId && s === n.value.modalId);
    },
    toggle(s, n) {
      const l = u.get(s);
      return l == null ? void 0 : l.value.toggle(n);
    },
    open(s) {
      return u.toggle(s, !0);
    },
    close(s) {
      return u.toggle(s, !1);
    },
    closeAll() {
      return Promise.allSettled([o.map((s) => s.value.toggle(!1))]);
    }
  });
  return Lo(u), u;
}
function Po(e) {
  const { modals: o, openedModals: t, openedModalOverlays: r, dynamicModals: d } = e, u = {
    deleteFromModals(s) {
      const n = o.findIndex((l) => l.value === s.value);
      n !== -1 && o.splice(n, 1);
    },
    moveToLastOpenedModals(s) {
      u.deleteFromOpenedModals(s), t.push(s);
    },
    deleteFromOpenedModals(s) {
      const n = t.findIndex((l) => l.value === s.value);
      n !== -1 && t.splice(n, 1);
    },
    moveToLastOpenedModalOverlays(s) {
      u.deleteFromOpenedModalOverlays(s), r.push(s);
    },
    deleteFromOpenedModalOverlays(s) {
      const n = r.findIndex((l) => l.value === s.value);
      n !== -1 && r.splice(n, 1);
    },
    async openLastOverlay() {
      var s;
      if (await Z(), r.forEach((n) => n.value.overlayVisible.value = !1), r.length > 0) {
        const n = r[r.length - 1];
        !((s = n.value.hideOverlay) != null && s.value) && (n.value.overlayVisible.value = !0);
      }
    },
    resolvedClosed(s) {
      var n, l, i;
      (l = (n = d[s]) == null ? void 0 : n.resolveClosed) == null || l.call(n), (i = d[s]) != null && i.keepAlive || d.splice(s, 1);
    },
    resolvedOpened(s) {
      var n, l;
      (l = (n = d[s]) == null ? void 0 : n.resolveOpened) == null || l.call(n);
    }
  };
  return u;
}
function ee() {
  const e = Io();
  if (!e)
    throw new Error(
      `[Vue Final Modal]: getActiveVfm was called with no active Vfm. Did you forget to install vfm?
	const vfm = createVfm()
	app.use(vfm)
This will fail in production.`
    );
  return e;
}
function Ao() {
  return oe(me);
}
function Le(e, o = Bo) {
  const { component: t, slots: r, ...d } = e, u = typeof r > "u" ? {} : Object.fromEntries(Object.entries(r).map(([s, n]) => ce(n) ? [s, n] : "component" in n ? [s, {
    ...n,
    component: Q(n.component)
  }] : [s, Q(n)]));
  return {
    ...d,
    component: Q(t || o),
    slots: u
  };
}
function $o(e) {
  const o = ie({
    id: Symbol("useModal"),
    modelValue: !!(e != null && e.defaultModelValue),
    resolveOpened: () => {
    },
    resolveClosed: () => {
    },
    attrs: {},
    ...Le(e)
  });
  no(() => {
    o != null && o.keepAlive || n();
  }), o.modelValue === !0 && (R ? R == null || R.dynamicModals.push(o) : Z(() => {
    const l = ee();
    l == null || l.dynamicModals.push(o);
  }));
  async function t() {
    let l;
    return R ? l = R : (await Z(), l = ee()), o.modelValue ? Promise.resolve("[Vue Final Modal] modal is already opened.") : (n(), o.modelValue = !0, l.dynamicModals.push(o), new Promise((i) => {
      o.resolveOpened = () => i("opened");
    }));
  }
  function r() {
    return o.modelValue ? (o.modelValue = !1, new Promise((l) => {
      o.resolveClosed = () => l("closed");
    })) : Promise.resolve("[Vue Final Modal] modal is already closed.");
  }
  function d(l) {
    const { slots: i, ...y } = Le(l, o.component);
    l.defaultModelValue !== void 0 && (o.defaultModelValue = l.defaultModelValue), (l == null ? void 0 : l.keepAlive) !== void 0 && (o.keepAlive = l == null ? void 0 : l.keepAlive), u(o, y), i && Object.entries(i).forEach(([c, M]) => {
      const b = o.slots[c];
      ce(b) ? o.slots[c] = M : Ie(b) && Ie(M) ? u(b, M) : o.slots[c] = M;
    });
  }
  function u(l, i) {
    i.component && (l.component = i.component), i.attrs && s(l.attrs, i.attrs);
  }
  function s(l, i) {
    return Object.entries(i).forEach(([y, c]) => {
      l[y] = c;
    }), l;
  }
  function n() {
    const l = ee(), i = l.dynamicModals.indexOf(o);
    i !== -1 && l.dynamicModals.splice(i, 1);
  }
  return {
    options: o,
    open: t,
    close: r,
    patchOptions: d,
    destroy: n
  };
}
function zo(e) {
  return e;
}
function Ie(e) {
  return "component" in e || "attrs" in e;
}
function Do(e, o) {
  return Object.keys(o).reduce((t, r) => (t[r] = e[r], t), {});
}
function Fo(e) {
  return e ? {
    "onUpdate:modelValue": (o) => e("update:modelValue", o),
    onBeforeClose: () => e("beforeClose"),
    onClosed: () => e("closed"),
    onBeforeOpen: () => e("beforeOpen"),
    onOpened: () => e("opened"),
    /** onClickOutside will only be emitted when clickToClose equal to `false` */
    onClickOutside: () => e("clickOutside")
  } : {};
}
function xo(e) {
  const { props: o, modalProps: t, emit: r } = e, d = C(() => Do(o, t)), u = Fo(r), s = _e();
  return C(() => ({
    ...d.value,
    ...u,
    ...s
  }));
}
const Ro = ["innerHTML"], Go = /* @__PURE__ */ se({
  __name: "ModalsContainer",
  setup(e) {
    const o = ee(), t = Ao(), r = Symbol("ModalsContainer"), d = C(() => {
      var u;
      return r === ((u = o.modalsContainers.value) == null ? void 0 : u[0]);
    });
    return o.modalsContainers.value.push(r), de(() => {
      o.modalsContainers.value = o.modalsContainers.value.filter((u) => u !== r);
    }), (u, s) => m(d) ? (I(!0), j(eo, { key: 0 }, Ve(m(o).dynamicModals, (n, l) => (I(), G(ae(n.component), W({
      key: n.id
    }, {
      displayDirective: n != null && n.keepAlive ? "show" : void 0,
      ...n.attrs
    }, {
      modelValue: n.modelValue,
      "onUpdate:modelValue": (i) => n.modelValue = i,
      onClosed: () => {
        var i, y;
        return (y = (i = m(t)).resolvedClosed) == null ? void 0 : y.call(i, l);
      },
      onOpened: () => {
        var i, y;
        return (y = (i = m(t)).resolvedOpened) == null ? void 0 : y.call(i, l);
      }
    }), oo({ _: 2 }, [
      Ve(n.slots, (i, y) => ({
        name: y,
        fn: ne(() => [
          m(ce)(i) ? (I(), j("div", {
            key: 0,
            innerHTML: i
          }, null, 8, Ro)) : "component" in i ? (I(), G(ae(i.component), De(W({ key: 1 }, i.attrs)), null, 16)) : (I(), G(ae(i), { key: 2 }))
        ])
      }))
    ]), 1040, ["modelValue", "onUpdate:modelValue", "onClosed", "onOpened"]))), 128)) : z("", !0);
  }
});
export {
  ko as CoreModal,
  Go as ModalsContainer,
  Bo as VueFinalModal,
  R as activeVfm,
  fe as coreModalProps,
  Yo as createVfm,
  Io as getActiveVfm,
  Lo as setActiveVfm,
  $o as useModal,
  zo as useModalSlot,
  ee as useVfm,
  xo as useVfmAttrs,
  Vo as vueFinalModalProps
};
