var t;function r(t,r,n){return n?[...new Set(t.concat(r))]:t.concat(r)}function n(t,r){return Object.prototype.hasOwnProperty.call(t,r)}function i(t){return!!t&&"object"==typeof t&&!Array.isArray(t)}function e(t,r){if(r<=0)return i(t);if(!i(t))return!1;const c=r-1,o=Object.keys(t);for(let r=0;r<o.length;r++)if(n(t,o[r])&&e(t[o[r]],c))return!0;return!1}function c(t){try{return JSON.stringify(t),!0}catch(t){return!1}}function o(t){return"__proto__"!==t&&"prototype"!==t&&"constructor"!==t}function a(){return a=Object.assign||function(t){for(var r=1;r<arguments.length;r++){var n=arguments[r];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t},a.apply(this,arguments)}function s(t,r){if(r<0)return{};const n=a({},t),e=Object.keys(n);for(let t=0;t<e.length;t++)i(n[e[t]])&&(n[e[t]]=s(n[e[t]],r-1));return n}function u(r){var n,i;return(r=r||{}).array=null==(n=r.array)||n,r.arrayDistinct=null!=(i=r.arrayDistinct)&&i,r.priority=r.priority||t.LEFT,r}function f(e,a,...s){if(!s.length)return a;const u=s.shift();if(i(a)&&i(u)){const s=Object.keys(u);for(let y=0;y<s.length;y++){const l=s[y];if(o(l))if(n(a,l)){if(e.strategy){if(void 0!==e.strategy(a,l,u[l]))continue}if(!c(u[l]))continue;if(i(a[l])&&i(u[l])){f(e,a[l],u[l]);continue}if(e.array&&Array.isArray(a[l])&&Array.isArray(u[l])){switch(e.priority){case t.LEFT:Object.assign(a,{[l]:r(a[l],u[l],e.arrayDistinct)});break;case t.RIGHT:Object.assign(a,{[l]:r(u[l],a[l],e.arrayDistinct)})}continue}e.priority===t.RIGHT&&Object.assign(a,{[l]:u[l]})}else Object.assign(a,{[l]:u[l]})}}return f(e,a,...s)}function y(t){const r=u(t);return(t,...n)=>f(r,t,...n)}!function(t){t.LEFT="left",t.RIGHT="right"}(t||(t={}));const l=y();export{t as PriorityName,f as baseMerger,u as buildOptions,y as createMerger,s as cutObject,n as hasOwnProperty,i as isObject,e as isObjectDeeperThan,o as isSafeKey,c as isSafeObject,l as merge,r as mergeArrays};
//# sourceMappingURL=index.mjs.map
